<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<style>
  /* body {
    display: flex;
    background-color: aquamarine;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    font-family: Arial, sans-serif;
  } */

  /* 添加容器样式 */
  .container {
    display: flex;
    flex-direction: row;
    gap: 20px;  /* 元素之间的间距 */
    align-items: flex-start;  /* 顶部对齐 */
  }

  #map {
    width: 800px;
    height: 600px;
    background-color: #f0f0f0;
  }

  #zone_joystick {
    position: relative;
    background: silver;
    box-sizing: content-box;
    height: 600px;
    width: 600px;
  }
</style>

<script type="text/javascript" src="./jslib/three.js"></script>
<script type="text/javascript" src="./jslib/eventemitter2.js"></script>
<script type="text/javascript" src="./jslib/roslib.js"></script>
<script type="text/javascript" src="./jslib/ros3d.js"></script>
<script type="text/javascript" src="./jslib/nipplejs.js"></script>

<script type="text/javascript">

var ros,
    viewer,
    gridClient,
    laserScan;

  /**
   * Setup all visualization elements when the page is loaded.
   */
  function init() {
    // Connect to ROS.
    ros = new ROSLIB.Ros({
      url : 'ws://192.168.50.130:9090'
    });

    // Create the main viewer.
    viewer = new ROS3D.Viewer({
      divID : 'map',
      width : 800,
      height : 600,
      antialias : false //禁用抗锯齿以提高性能
    });

    //初始化相机位置
    viewer.cameraControls.camera.position.set(-0.0000001, 0, 10);

    // Setup the map client.
    gridClient = new ROS3D.OccupancyGridClient({
      ros : ros,
      rootObject : viewer.scene,
      continuous : true,
    });

    laserScan = new ROS3D.LaserScan({
      ros : ros,
      rootObject : viewer.scene,
      topic : '/scan',
      tfClient : new ROSLIB.TFClient({
        ros : ros,
        fixedFrame : 'map',
        angularThres : 0.01,
        transThres : 0.01,
        rate : 10.0
      }),
      material: {
        size: 0.05,
        color: 0xff00ff
      }
    });
  }

  function bottom1() {
    viewer.cameraControls.camera.position.x = -0.0000001;
    viewer.cameraControls.camera.position.y = 0;
    viewer.cameraControls.camera.position.z = 1;
  }

  function bottom2() {
    viewer.cameraControls.center.x = 0;
    viewer.cameraControls.center.y = 0.74;
    viewer.cameraControls.center.z = 0;
  }

  function bottom3() {
    viewer.start();
  }
</script>
</head>

<body onload="init()">
  <h1>Simple Map Example</h1>
  <button type="button" onclick="bottom1()">button1</button>
  <button type="button" onclick="bottom2()">button2</button>
  <button type="button" onclick="bottom3()">button3</button>
  <br><br>
  <div class="container">
    <div id="map"></div>
    <div id="zone_joystick">
      <div id="joystick"></div>
    </div>
  </div>

  <script>
    var options = {
        zone: document.getElementById('joystick'),
        mode: 'static',
        position: { left: '50%', top: '50%' },
        color: 'red',
        size: 300,
    };

    var joystick = nipplejs.create(options);
    
    // 摇杆状态
    var joystickState = {
        active: false,
        distance: 0,
        angle: 0
    };

    // 更新相机位置
    function updateCamera() {
        if (joystickState.active) {
            // 相机与中心点距离为1时，摇杆单位距离对应的相机移动距离参数
            var cameraDistancePerJoystickUnit = 0.00015;

            // 计算相机朝向二维向量
            var cameraDirection = new THREE.Vector2();
            cameraDirection.subVectors(viewer.cameraControls.center, viewer.cameraControls.camera.position);
            // 计算相机朝向的角度
            var cameraAngle = Math.atan2(cameraDirection.y, cameraDirection.x);
            // 计算相机和中心点的距离
            var cameraDistance = viewer.cameraControls.camera.position.distanceTo(viewer.cameraControls.center);

            // 计算相机和中心点移动的增量
            var cameraDeltaX = joystickState.distance * Math.sin(joystickState.angle + cameraAngle) * cameraDistancePerJoystickUnit * cameraDistance;
            var cameraDeltaY = joystickState.distance * -Math.cos(joystickState.angle + cameraAngle) * cameraDistancePerJoystickUnit * cameraDistance;
            var centerDeltaX = joystickState.distance * Math.sin(joystickState.angle + cameraAngle) * cameraDistancePerJoystickUnit * cameraDistance;
            var centerDeltaY = joystickState.distance * -Math.cos(joystickState.angle + cameraAngle) * cameraDistancePerJoystickUnit * cameraDistance;

            viewer.cameraControls.camera.position.add(new THREE.Vector3(cameraDeltaX, cameraDeltaY, 0));
            viewer.cameraControls.center.add(new THREE.Vector3(centerDeltaX, centerDeltaY, 0));
        }
        requestAnimationFrame(updateCamera);
    }

    // 启动动画循环
    updateCamera();

    // 摇杆移动事件
    joystick.on('move', function (evt, data) {
        joystickState.active = true;
        joystickState.distance = data.distance;
        joystickState.angle = data.angle.radian;
    });

    // 摇杆释放事件
    joystick.on('end', function () {
        joystickState.active = false;
        joystickState.distance = 0;
        joystickState.angle = 0;
    });
  </script>
</body>
</html>
