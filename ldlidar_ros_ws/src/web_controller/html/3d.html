<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="cache-control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="expires" content="0">

<style>
  html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;  /* 防止出现滚动条 */
  }

  .container {
    display: flex;
    width: 100vw;     /* 占满整个视口宽度 */
    height: 100vh;    /* 占满整个视口高度 */
    gap: 0;          /* 移除间距 */
    align-items: stretch;  /* 子元素拉伸以填充容器高度 */
  }

  #map {
    flex: 1;        /* 弹性布局占比为1 */
    height: 100%;   /* 填满容器高度 */
    background-color: #f0f0f0;
  }

  #control-zone {
    flex: 1;        /* 弹性布局占比为1 */
    position: relative;
    background: silver;
    height: 100%;   /* 填满容器高度 */
    display: flex;
    flex-direction: column; /* 垂直方向排列 */
  }

  #joystick {
    position: absolute;
    width: 150px;   /* 摇杆容器宽度 */
    height: 150px;  /* 摇杆容器高度 */
    border-radius: 50%;  /* 圆形 */
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);  /* 居中定位 */
  }

  .connection-info {
    position: relative;
    padding: 5px;
    text-align: center;
    flex-shrink: 0;       /* 防止内容压缩 */
  }

  .status {
    margin: 5px;
    padding: 10px;
    border-radius: 5px;
    font-weight: bold;
  }

  .status.connected {
    background-color: #27ae60;
    color: white;
  }

  .status.disconnected {
    background-color: #e74c3c;
    color: white;
  }

  button {
    margin: 5px;
    padding: 5px 10px;
    font-size: 16px;
    border: 2px solid #3498db;
    border-radius: 5px;
    background-color: #3498db;
    color: #ffffff;
    cursor: pointer;
    transition: background-color 0.3s;
  }

  button:hover {
    background-color: #2980b9;
  }

  input[type="text"] {
    padding: 5px;
    border: 1px solid #ccc;
    border-radius: 3px;
    width: 80px;
  }

  .joystick-container {
    position: relative;
    flex: 1;              /* 占用剩余空间 */
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .mapping-controls {
    position: relative;
    padding: 5px;
    text-align: center;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
  }

  .status-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background-color: #95a5a6;  /* 默认灰色 */
    transition: background-color 0.3s;
  }

  .status-dot.active {
    background-color: #27ae60;  /* 运行时绿色 */
  }

  .modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
  }

  .modal-content {
    background-color: #fefefe;
    position: relative;
    top: 50%;                     /* 从顶部偏移50% */
    transform: translateY(-50%);   /* 向上偏移自身高度的50% */
    margin: 0 auto;               /* 水平居中 */
    padding: 20px;
    border-radius: 5px;
    width: 300px;
    text-align: center;
  }

  .modal-content input {
    width: 200px;
    margin: 10px 0;
  }

  .modal-buttons {
    margin-top: 15px;
  }

  .map-list {
    max-height: 200px;
    overflow-y: auto;
    margin: 10px 0;
    border: 1px solid #ccc;
    border-radius: 3px;
  }

  .map-item {
    padding: 8px 15px;
    cursor: pointer;
    transition: background-color 0.2s;
  }

  .map-item:hover {
    background-color: #f0f0f0;
  }

  .map-item.selected {
    background-color: #3498db;
    color: white;
  }

  .no-maps {
    padding: 15px;
    color: #666;
    font-style: italic;
  }

  .log-modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
  }
  
  .log-content {
      background-color: #fefefe;
      position: relative;
      top: 50%;
      transform: translateY(-50%);
      margin: 0 auto;
      padding: 20px;
      border-radius: 5px;
      width: 80%;
      height: 70%;
      display: flex;
      flex-direction: column;
  }
  
  .log-area {
      flex: 1;
      overflow-y: auto;
      background-color: #2b2b2b;
      color: #f0f0f0;
      padding: 10px;
      font-family: monospace;
      font-size: 14px;
      line-height: 1.5;
      white-space: pre-wrap;
      border-radius: 3px;
  }

  .log-debug {
      color: #888888;  /* 灰色 */
  }
  
  .log-info {
      color: #f0f0f0;  /* 白色 */
  }
  
  .log-warn {
      color: #f1c40f;  /* 黄色 */
  }
  
  .log-error {
      color: #e74c3c;  /* 红色 */
  }
  
  .log-fatal {
      color: #c0392b;  /* 深红色 */
      font-weight: bold;
  }
  
  .log-controls {
      margin-top: 10px;
      display: flex;
      gap: 10px;
      justify-content: flex-end;
  }
</style>

<script type="text/javascript" src="./jslib/three.js"></script>
<script type="text/javascript" src="./jslib/eventemitter2.js"></script>
<script type="text/javascript" src="./jslib/roslib.js"></script>
<script type="text/javascript" src="./jslib/ros3d.js"></script>
<script type="text/javascript" src="./jslib/nipplejs.js"></script>

<script type="text/javascript">

var ros,
    viewer,
    gridClient,
    laserScan;
var startClient,
    stopClient,
    statusClient,
    mapOperationClient;  // 添加地图保存服务客户端

// 日志相关变量
var logSubscriber;
var autoScroll = true;
var logBuffer = [];
const MAX_LOG_LINES = 1000;  // 最大日志行数

function init() {
    // 获取当前页面的主机名/IP地址
    const currentHost = window.location.hostname || 'localhost';
    const port = document.getElementById('port').value;
    const rosbridgeUrl = `ws://${currentHost}:${port}`;
    
    // Connect to ROS
    ros = new ROSLIB.Ros({
        url: rosbridgeUrl
    });

    const statusElement = document.getElementById('status');

    ros.on('connection', () => {
        console.log('Connected to ROS Bridge');
        statusElement.innerHTML = `已连接到 ${rosbridgeUrl}`;
        statusElement.className = 'status connected';
        
        // 创建viewer等其他对象
        initializeViewer();
        // 初始化服务客户端
        initServiceClients();

        // 查询建图状态
        updateMappingStatusDot();

        // 初始化日志订阅
        initLogSubscriber();
    });

    ros.on('error', (error) => {
        console.error('Error connecting to ROS: ', error);
        statusElement.innerHTML = `连接失败: ${error}`;
        statusElement.className = 'status disconnected';
    });

    ros.on('close', () => {
        console.log('Disconnected from ROS');
        statusElement.innerHTML = '已断开连接';
        statusElement.className = 'status disconnected';
        cleanupViewer();
        document.getElementById("mapping-status").classList.remove("active");
        
        // 清理服务客户端
        startClient = null;
        stopClient = null;
        statusClient = null;
        mapOperationClient = null;
});
}

function initializeViewer() {
    // 清理旧的订阅和场景对象
    cleanupViewer();

    // 如果viewer不存在才创建新的实例
    if (!viewer) {
        viewer = new ROS3D.Viewer({
            divID : 'map',
            width : document.documentElement.clientWidth / 2,
            height : document.documentElement.clientHeight,
            antialias : false
        });

        //初始化相机位置
        viewer.cameraControls.camera.position.set(-0.0000001, 0, 10);
    }

    // Setup the map client.
    gridClient = new ROS3D.OccupancyGridClient({
      ros : ros,
      rootObject : viewer.scene,
      continuous : true,
    });

    laserScan = new ROS3D.LaserScan({
      ros : ros,
      rootObject : viewer.scene,
      topic : '/scan',
      tfClient : new ROSLIB.TFClient({
        ros : ros,
        fixedFrame : 'map',
        angularThres : 0.01,
        transThres : 0.01,
        rate : 10.0
      }),
      material: {
        size: 0.05,
        color: 0xff00ff
      }
    });
}

// 初始化服务客户端
function initServiceClients() {
    startClient = new ROSLIB.Service({
        ros: ros,
        name: "/start_mapping",
        serviceType: "std_srvs/Trigger"
    });

    stopClient = new ROSLIB.Service({
        ros: ros,
        name: "/stop_mapping",
        serviceType: "std_srvs/Trigger"
    });

    statusClient = new ROSLIB.Service({
        ros: ros,
        name: "/mapping_status",
        serviceType: "std_srvs/Trigger"
    });

    mapOperationClient = new ROSLIB.Service({
        ros: ros,
        name: "/map_operation",
        serviceType: "web_controller/MapOperation"
    });
}

// 初始化日志订阅
function initLogSubscriber() {
    if (logSubscriber) {
        logSubscriber.unsubscribe();
    }

    // 订阅rosout主题
    logSubscriber = new ROSLIB.Topic({
        ros: ros,
        name: '/rosout',
        messageType: 'rosgraph_msgs/Log'
    });

    logSubscriber.subscribe(function(message) {
        addLogMessage(`[${message.name}] ${message.msg}`, message.level);
    });
}

// 添加日志消息
function addLogMessage(message, level) {
    const timestamp = new Date().toLocaleTimeString();
    let levelStr = '';
    let levelClass = '';
    
    // 从level获取日志级别
    if (typeof level === 'number') {
        switch(level) {
            case 1: // Debug
                levelStr = '[DEBUG]';
                levelClass = 'log-debug';
                break;
            case 2: // Info
                levelStr = '[INFO]';
                levelClass = 'log-info';
                break;
            case 4: // Warn
                levelStr = '[WARN]';
                levelClass = 'log-warn';
                break;
            case 8: // Error
                levelStr = '[ERROR]';
                levelClass = 'log-error';
                break;
            case 16: // Fatal
                levelStr = '[FATAL]';
                levelClass = 'log-fatal';
                break;
            default:
                levelStr = '[INFO]';
                levelClass = 'log-info';
        }
    } else {
        levelStr = '[INFO]';
        levelClass = 'log-info';
    }
    
    // 使用HTML格式存储日志
    logBuffer.push(`<span class="${levelClass}">[${timestamp}]${levelStr} ${message}</span>`);
    
    // 限制日志行数
    if (logBuffer.length > MAX_LOG_LINES) {
        logBuffer.shift();
    }
    
    // 更新显示
    updateLogDisplay();
}

// 更新日志显示
function updateLogDisplay() {
    const logArea = document.getElementById('logArea');
    logArea.innerHTML = logBuffer.join('<br>');
    
    // 如果开启了自动滚动，滚动到底部
    if (autoScroll) {
        logArea.scrollTop = logArea.scrollHeight;
    }
}

// 切换日志窗口显示
function toggleLogModal() {
    const modal = document.getElementById('logModal');
    if (modal.style.display === 'block') {
        closeLogModal();
    } else {
        modal.style.display = 'block';
        updateLogDisplay();
    }
}

// 关闭日志窗口
function closeLogModal() {
    document.getElementById('logModal').style.display = 'none';
}

// 切换自动滚动
function toggleAutoScroll() {
    autoScroll = !autoScroll;
    document.getElementById('autoScrollBtn').textContent = 
        `自动滚动：${autoScroll ? '开' : '关'}`;
}

// 清除日志
function clearLog() {
    logBuffer = [];
    updateLogDisplay();
}

function connect() {
    if (ros) {
        ros.close();
        cleanupViewer();  // 清理旧的实例
    }
    init();
}

// 清理viewer和订阅的对象
function cleanupViewer() {
    if (laserScan) {
        laserScan.unsubscribe();
        if (viewer && viewer.scene) {
            viewer.scene.remove(laserScan);
        }
        laserScan = null;
    }
    
    if (gridClient) {
        gridClient.unsubscribe();
        if (viewer && viewer.scene) {
            viewer.scene.remove(gridClient);
        }
        gridClient = null;
    }

    if (viewer && viewer.scene) {
        // 只清理场景中的对象，保留viewer实例
        while(viewer.scene.children.length > 0){ 
            viewer.scene.remove(viewer.scene.children[0]); 
        }
    }
}

  function bottom1() {
    viewer.cameraControls.camera.position.x = -0.0000001;
    viewer.cameraControls.camera.position.y = 0;
    viewer.cameraControls.camera.position.z = 1;
  }

  function bottom2() {
    viewer.cameraControls.center.x = 0;
    viewer.cameraControls.center.y = 0.74;
    viewer.cameraControls.center.z = 0;
  }

  function bottom3() {
    viewer.start();
  }

  window.addEventListener('resize', function() {
    viewer.resize(
      document.documentElement.clientWidth / 2,
      document.documentElement.clientHeight
    );
  });

// 更新状态点显示
function updateMappingStatusDot(callback) {
    if (!statusClient) {
        console.warn('状态查询服务未初始化');
        return;
    }
    
    const request = new ROSLIB.ServiceRequest({});
    statusClient.callService(request, (result) => {
        if (result.success) {
          document.getElementById("mapping-status").classList.add("active");
        } else {
          document.getElementById("mapping-status").classList.remove("active");
        }
    });
}

// 修改启动建图函数
function startMapping() {
    if (!startClient) return;
    const request = new ROSLIB.ServiceRequest({});
    startClient.callService(request, (result) => {
        if (result.success) {
            // 启动成功后查询状态
            updateMappingStatusDot();
        }
    });
}

// 修改停止建图函数
function stopMapping() {
    if (!stopClient) return;
    const request = new ROSLIB.ServiceRequest({});
    stopClient.callService(request, (result) => {
        if (result.success) {
            // 停止成功后查询状态
            updateMappingStatusDot();
        }
    });
}

// 当前选中的地图名称
var selectedMapName = null;

// 显示加载地图弹窗
function loadMap() {
    if (!mapOperationClient) {
        console.warn('地图操作服务未初始化');
        return;
    }

    // 获取地图列表
    const request = new ROSLIB.ServiceRequest({
        operation: "list",
        map_name: ""
    });

    mapOperationClient.callService(request, (result) => {
        if (result.success) {
            const mapList = document.getElementById('mapList');
            mapList.innerHTML = ''; // 清空现有列表
            
            if (result.map_list.length === 0) {
                mapList.innerHTML = '<div class="no-maps">暂无保存的地图</div>';
                return;
            }

            // 创建地图列表
            result.map_list.forEach(mapName => {
                const div = document.createElement('div');
                div.className = 'map-item';
                div.textContent = mapName;
                div.onclick = () => selectMap(div, mapName);
                mapList.appendChild(div);
            });

            // 显示弹窗
            document.getElementById('loadMapModal').style.display = 'block';
        } else {
            alert('获取地图列表失败: ' + result.message);
        }
    });
}

// 选择地图
function selectMap(element, mapName) {
    // 移除其他项的选中状态
    document.querySelectorAll('.map-item').forEach(item => {
        item.classList.remove('selected');
    });
    
    // 添加选中状态
    element.classList.add('selected');
    selectedMapName = mapName;
    
    // 启用确认按钮
    document.getElementById('confirmLoadBtn').disabled = false;
}

// 确认加载地图
function confirmLoadMap() {
    if (!selectedMapName) return;
    
    const request = new ROSLIB.ServiceRequest({
        operation: "load",
        map_name: selectedMapName
    });

    mapOperationClient.callService(request, (result) => {
        if (result.success) {
            alert('地图加载成功');
            closeLoadMapModal();
        } else {
            alert('地图加载失败: ' + result.message);
        }
    });
}

// 关闭加载地图弹窗
function closeLoadMapModal() {
    document.getElementById('loadMapModal').style.display = 'none';
    selectedMapName = null;
    document.getElementById('confirmLoadBtn').disabled = true;
}

// 显示保存地图弹窗
function saveMap() {
    document.getElementById('saveMapModal').style.display = 'block';
    document.getElementById('mapName').value = 'map';  // 设置默认值
}

// 关闭弹窗
function closeSaveMapModal() {
    document.getElementById('saveMapModal').style.display = 'none';
}

// 确认保存地图
function confirmSaveMap() {
    if (!mapOperationClient) {
        console.warn('地图保存服务未初始化');
        return;
    }
    
    const mapName = document.getElementById('mapName').value.trim();
    if (!mapName) {
        alert('请输入地图名称');
        return;
    }
    
    const request = new ROSLIB.ServiceRequest({
        operation: "save",
        map_name: mapName
    });

    mapOperationClient.callService(request, (result) => {
        if (result.success) {
            alert('地图保存成功');
            closeSaveMapModal();
        } else {
            alert('地图保存失败: ' + result.message);
        }
    });
}

// 修改原有的事件监听器以支持新的弹窗
window.addEventListener('keydown', function(event) {
    if (event.key === 'Escape') {
        closeSaveMapModal();
        closeLoadMapModal();
        closeLogModal();
    }
});

// 点击弹窗外部关闭弹窗
window.addEventListener('click', function(event) {
    if (event.target === document.getElementById('saveMapModal')) {
        closeSaveMapModal();
    }
    if (event.target === document.getElementById('loadMapModal')) {
        closeLoadMapModal();
    }
    if (event.target === document.getElementById('logModal')) {
        closeLogModal();
    }
});
</script>
</head>

<body onload="init()">
  <div class="container">
    <div id="map"></div>
    <div id="control-zone">
        <div class="connection-info">
            <div id="status" class="status disconnected">未连接</div>
            <div>
                <label for="port">Rosbridge端口：</label>
                <input type="text" id="port" value="9090" />
                <button onclick="connect()">连接</button>
                <button onclick="toggleLogModal()">日志</button>
            </div>
        </div>
        <div class="mapping-controls">
          <div id="mapping-status" class="status-dot"></div>
          <button onclick="startMapping()">启动建图</button>
          <button onclick="stopMapping()">停止建图</button>
          <button onclick="loadMap()">加载地图</button>
          <button onclick="saveMap()">保存地图</button>
        </div>
        <div class="joystick-container">
            <div id="joystick"></div>
        </div>
    </div>
  </div>

  <!-- 添加保存地图弹窗 -->
  <div id="saveMapModal" class="modal">
    <div class="modal-content">
      <h3>保存地图</h3>
      <div>
        <label for="mapName">地图名称：</label>
        <input type="text" id="mapName" value="map" />
      </div>
      <div class="modal-buttons">
        <button onclick="confirmSaveMap()">确认</button>
        <button onclick="closeSaveMapModal()">取消</button>
      </div>
    </div>
  </div>

  <div id="loadMapModal" class="modal">
    <div class="modal-content">
        <h3>加载地图</h3>
        <div id="mapList" class="map-list">
        </div>
        <div class="modal-buttons">
            <button onclick="confirmLoadMap()" id="confirmLoadBtn" disabled>确认</button>
            <button onclick="closeLoadMapModal()">取消</button>
        </div>
    </div>
  </div>

  <div id="logModal" class="log-modal">
      <div class="log-content">
          <div id="logArea" class="log-area"></div>
          <div class="log-controls">
              <button onclick="toggleAutoScroll()" id="autoScrollBtn">自动滚动：开</button>
              <button onclick="clearLog()">清除</button>
              <button onclick="closeLogModal()">关闭</button>
          </div>
      </div>
  </div>

  <script>
    var options = {
        zone: document.getElementById('joystick'),
        mode: 'static',
        position: { left: '50%', top: '50%' },
        color: 'red',
        size: 150,
    };

    var joystick = nipplejs.create(options);
    
    // 摇杆状态
    var joystickState = {
        active: false,
        distance: 0,
        angle: 0
    };

    // 更新相机位置
    function updateCamera() {
        if (joystickState.active) {
            // 相机与中心点距离为1时，摇杆单位距离对应的相机移动距离参数
            var cameraDistancePerJoystickUnit = 0.00015;

            // 计算相机朝向二维向量
            var cameraDirection = new THREE.Vector2();
            cameraDirection.subVectors(viewer.cameraControls.center, viewer.cameraControls.camera.position);
            // 计算相机朝向的角度
            var cameraAngle = Math.atan2(cameraDirection.y, cameraDirection.x);
            // 计算相机和中心点的距离
            var cameraDistance = viewer.cameraControls.camera.position.distanceTo(viewer.cameraControls.center);

            // 计算相机和中心点移动的增量
            var cameraDeltaX = joystickState.distance * Math.sin(joystickState.angle + cameraAngle) * cameraDistancePerJoystickUnit * cameraDistance;
            var cameraDeltaY = joystickState.distance * -Math.cos(joystickState.angle + cameraAngle) * cameraDistancePerJoystickUnit * cameraDistance;
            var centerDeltaX = joystickState.distance * Math.sin(joystickState.angle + cameraAngle) * cameraDistancePerJoystickUnit * cameraDistance;
            var centerDeltaY = joystickState.distance * -Math.cos(joystickState.angle + cameraAngle) * cameraDistancePerJoystickUnit * cameraDistance;

            viewer.cameraControls.camera.position.add(new THREE.Vector3(cameraDeltaX, cameraDeltaY, 0));
            viewer.cameraControls.center.add(new THREE.Vector3(centerDeltaX, centerDeltaY, 0));
        }
        requestAnimationFrame(updateCamera);
    }

    // 启动动画循环
    updateCamera();

    // 摇杆移动事件
    joystick.on('move', function (evt, data) {
        joystickState.active = true;
        joystickState.distance = data.distance;
        joystickState.angle = data.angle.radian;
    });

    // 摇杆释放事件
    joystick.on('end', function () {
        joystickState.active = false;
        joystickState.distance = 0;
        joystickState.angle = 0;
    });
  </script>
</body>
</html>
